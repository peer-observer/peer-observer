syntax = "proto2";

package rpc_extractor;

message rpc {
  oneof rpc_event {
    PeerInfos peer_infos = 1;
    MempoolInfo mempool_info = 2;
    uint32 uptime = 3;
    NetTotals net_totals = 4;
    MemoryInfo memory_info = 5;
    AddrManInfo addrman_info = 6;
    ChainTxStats chain_tx_stats = 7;
  }
}

// A getpeerinfo RPC response from Bitcoin Core.
message PeerInfos {
  repeated PeerInfo infos = 1;
}

// Information about a single peer.
message PeerInfo {
  required uint32   id                      = 1;  // The peer_id of this peer.
  required string   address                 = 2;  // The address of this peer (host:port).
  required string   address_bind            = 3;  // The bind address of the connection to the peer (ip:port).
  required string   address_local           = 4;  // Local address as reported by the peer (ip:port)
  required string   network                 = 5;  // Network (ipv4, ipv6, onion, i2p, cjdns, not_publicly_routable, or empty)
  required uint32   mapped_as               = 6;  // Mapped AS (Autonomous System) number
  required string   services                = 7;  // The services offered
  required bool     relay_transactions      = 8;  // Whether we relay transactions to this peer
  required int64    last_send               = 9;  // The UNIX epoch time of the last send
  required int64    last_received           = 10; // The UNIX epoch time of the last receive
  required int64    last_transaction        = 11; // The UNIX epoch time of the last valid transaction received from this peer
  required int64    last_block              = 12; // The UNIX epoch time of the last block received from this peer
  required uint64   bytes_sent              = 13; // The total bytes sent
  required uint64   bytes_received          = 14; // The total bytes received
  required int64    connection_time         = 15; // The UNIX epoch time of the connection
  required int64    time_offset             = 16; // The time offset in seconds
  required double   ping_time               = 17; // The last ping time in milliseconds (ms), if any
  required double   minimum_ping            = 18; // The minimum observed ping time in milliseconds (ms), if any
  required double   ping_wait               = 19; // The duration in milliseconds (ms) of an outstanding ping (if non-zero)
  required uint32   version                 = 20; // The peer version, such as 70001
  required string   subversion              = 21; // The string version
  required bool     inbound                 = 22; // Inbound (true) or Outbound (false)
  required bool     bip152_hb_to            = 23; // Whether we selected peer as (compact blocks) high-bandwidth peer
  required bool     bip152_hb_from          = 24; // Whether peer selected us as (compact blocks) high-bandwidth peer
  required int64    starting_height         = 25; // The starting height (block) of the peer
  required int64    synced_headers          = 26; // The last header we have in common with this peer
  required int64    synced_blocks           = 27; // The last block we have in common with this peer
  repeated uint64   inflight                = 28; // The heights of blocks we're currently asking from this peer
  required bool     addr_relay_enabled      = 29; // Whether we participate in address relay with this peer
  required uint64   addr_processed          = 30; // The total number of addresses processed, excluding those dropped due to rate limiting
  required uint64   addr_rate_limited       = 31; // The total number of addresses dropped due to rate limiting
  repeated string   permissions             = 32; // Any special permissions that have been granted to this peer
  required double   minfeefilter            = 33; // The minimum fee rate for transactions this peer accepts
  map<string, uint64> bytes_sent_per_message = 34; // The total bytes sent aggregated by message type.
  map<string, uint64> bytes_received_per_message = 35; // The total bytes received aggregated by message type.
  required string   connection_type         = 36; // Type of connection: e.g. outbound-full-relay, block-relay-only, inbound, manual, addr-fetch, feeler
  required string   transport_protocol_type = 37; // Type of transport protocol (v1, v2)
  // session ID is not implemented, since I'm not sure we need them?


  // temporary fields
  required uint64   inv_to_send             = 38; // How many txs we have queued to announce to this peer
  required double   cpu_load                = 129; // Total CPU time spent processing messages to/from the peer, in per milles (â€°) of the connection duration, if supported by the platform and measured.
}

// A getmempoolinfo RPC result: Returns details on the active state of the TX memory pool.
message MempoolInfo {
  required bool     loaded                  = 1; // True if the initial load attempt of the persisted mempool finished
  required int64    size                    = 2; // Current tx count
  required int64    bytes                   = 3; // Sum of all virtual transaction sizes as defined in BIP 141. Differs from actual serialized size because witness data is discounted
  required int64    usage                   = 4; // Total memory usage for the mempool
  required double   total_fee               = 5; // Total fees for the mempool in BTC, ignoring modified fees through prioritisetransaction
  required int64    max_mempool             = 6; // Maximum memory usage for the mempool
  required double   mempoolminfee           = 7; // Minimum fee rate in BTC/kvB for tx to be accepted. Is the maximum of minrelaytxfee and minimum mempool fee
  required double   minrelaytxfee           = 8; // Current minimum relay fee for transactions
  required double   incrementalrelayfee     = 9; // minimum fee rate increment for mempool limiting or replacement in BTC/kvB
  required int64    unbroadcastcount        = 10; // Current number of transactions that haven't passed initial broadcast yet
  required bool     fullrbf                 = 11; // True if the mempool accepts RBF without replaceability signaling inspection (DEPRECATED)
  // These were both added in v30.0, but aren't in v29. Can be added later, if needed
  // required bool     permitbaremultisig      = 12; // True if the mempool accepts transactions with bare multisig outputs
  // required uint32   maxdatacarriersize      = 13; // Maximum number of bytes that can be used by OP_RETURN outputs in the mempool
}

// A getnettotals RPC result: Returns information about network traffic, including bytes in, bytes out, and current time.
message NetTotals {
  required uint64       total_bytes_received     = 1; // Total bytes received
  required uint64       total_bytes_sent         = 2; // Total bytes sent
  required uint64       time_millis              = 3; // Current UNIX time in milliseconds
  required UploadTarget upload_target            = 4; // Upload target statistics
}

// Upload target statistics. Part of getnettotals.
message UploadTarget {
  required uint64 timeframe                = 1; // Length of the measuring timeframe in seconds
  required uint64 target                   = 2; // Target in bytes
  required bool   target_reached           = 3; // True if target is reached
  required bool   serve_historical_blocks  = 4; // True if serving historical blocks
  required uint64 bytes_left_in_cycle      = 5; // Bytes left in current time cycle
  required uint64 time_left_in_cycle       = 6; // Seconds left in current time cycle
}

// A getmemoryinfo RPC result: Returns information about memory usage.
message MemoryInfo {
  required uint64 used         = 1; // Number of bytes used
  required uint64 free         = 2; // Number of bytes available in current arenas
  required uint64 total        = 3; // Total number of bytes managed
  required uint64 locked       = 4; // Amount of bytes that succeeded locking
  required uint64 chunks_used  = 5; // Number of allocated chunks
  required uint64 chunks_free  = 6; // Number of unused chunks
}

// A getaddrmaninfo RPC result: Returns address manager information.
message AddrManInfo {
  map<string, AddrManInfoNetwork> networks = 1; // Address counts by network type
}

// Address manager information by network. Part of getaddrmaninfo.
message AddrManInfoNetwork {
  required uint64 new   = 1; // Number of addresses in new table
  required uint64 tried = 2; // Number of addresses in tried table
  required uint64 total = 3; // Total addresses (new + tried)
}

// A getchaintxstats RPC result: Computes statistics about the total number and rate of transactions in the chain.
// Note: The Bitcoin Core RPC accepts optional `nblocks` (window size, default ~1 month) and `blockhash` (end block,
// default chain tip) parameters, but the corepc client uses defaults which is appropriate for periodic metrics.
// See: https://github.com/bitcoin/bitcoin/blob/938d7aacabd0bb3784bb3e529b1ed06bb2891864/src/rpc/blockchain.cpp#L1758
// See: https://github.com/rust-bitcoin/corepc/blob/master/client/src/client_sync/v17/blockchain.rs#L137
message ChainTxStats {
  required int64  time                      = 1; // The timestamp for the final block in the window, expressed in UNIX epoch time
  required int64  tx_count                  = 2; // The total number of transactions in the chain up to that point
  required string window_final_block_hash   = 3; // The hash of the final block in the window
  required int64  window_final_block_height = 4; // The height of the final block in the window
  required int64  window_block_count        = 5; // Size of the window in number of blocks
  optional int64  window_tx_count           = 6; // The number of transactions in the window (only if window_block_count > 0)
  optional int64  window_interval           = 7; // The elapsed time in the window in seconds (only if window_block_count > 0)
  optional double tx_rate                   = 8; // The average rate of transactions per second in the window (only if window_interval > 0)
}
